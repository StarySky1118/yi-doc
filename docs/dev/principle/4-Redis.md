# Redis

## Redis 常见数据类型应用场景

### String

String 类型可以存储字符串或数字。

1. 自增计数

Redis 和 MySQL 均可以通过一条命令实现字段值的自增，Redis 命令的执行是单线程的，没有并发问题，MySQL InnoDB 引擎也可以通过行级锁保证多线程情况下自增操作的正确性。但显然 MySQL 有更大的开销，Redis 的单线程设计十分适合使用 String 作自增计数。

2. 分布式锁

Redis 的 `set`命令有个参数 `nx`，意为键不存在时插入，这个命令非常适合分布式锁的加锁操作。Redis 命令执行是单线程的，这样就只有一个线程可以获取到锁，value 是客户端的标识。
解锁使用 Lua 脚本，首先判断锁是否属于客户端，若属于客户端再删除。

### Set

Set 中的元素无序、不可重复、支持各种集合运算。

1. 唯一性操作

Set 可进行自动去重，若我们希望操作只能进行一次，可以使用 Set 存储操作。例如点赞操作。

2. 共同关注

Set 支持集合运算，可用于实现共同关注。

3. 抽奖活动

Set 提供了随机获取元素和随机删除元素的命令，因此可以实现抽奖活动。

### List

### Hash

Hash 可以存储多个 KV，因此可用于缓存对象。

### ZSet

ZSet 元素带有分数且自动维护顺序，非常适合实现排行榜。

## Redis 数据类型底层数据结构

Redis 常用数据类型包括 String、Hash、ZSet、List、Set。
String 底层数据结构为 SDS。List 底层数据结构为 quicklist。Set 底层数据结构为 hash 和整数集合。 Hash 底层数据结构为 listpack 和 hash。ZSet 底层数据结构为链表和跳表

### String

Redis String 类型底层数据结构为 SDS(Simple Dynamic String)，简单动态字符串。与 C 语言字符数组相比，优势在于：

1. 维护字符串长度 `len` 属性，获取字符串长度时间复杂度为![](https://cdn.nlark.com/yuque/__latex/a2006f1ac61cb1902beacb3e29fff089.svg#card=math&code=O%281%29&id=GaSSd)
2. 维护了 `len`属性，可以存储 `\0`，二进制安全
3. 修改字符串时，自动判断空间是否满足需求，不满足需求自动扩容
4. 采用专门编译优化，节省内存空间

### List

Redis List 底层数据结构为 quicklist。quicklist 在 ziplist 基础上作了进一步划分，quicklist 的每个结点都指向了一个压缩列表。

### Set

当 Set 中均为整数并且元素个数小于 512 个，使用整数集合数据结构；否则使用 Hash。
整数集合本质上是数组，这个数组的类型并不是直接使用 64 位整数，而是根据插入的整数情况进行升级，这样可以节省内存空间。

### Hash

Redis Hash 类型底层数据结构为压缩链表(ziplist)或哈希表。
当元素个数较少、值较小时，使用压缩链表，否则使用哈希表。
压缩链表是对普通链表的改进，普通链表是带虚拟头结点的双向链表，由于链表结点在内存空间中不连续，无法利用 CPU 缓存，因此出现了压缩链表。压缩链表是使用了连续内存空间的链表。
Redis 哈希表的实现方式也是数组+拉链法，将 key 输入哈希函数获取下标，若出现哈希冲突使用链表链接。如果哈希冲突过于严重，会导致拉链过长，使用 rehash 解决这个问题，即将数据拷贝到长度更大的数组，减少哈希冲突。rehash 触发条件是达到负载因子 load factor 的阈值，负载因子即哈希表存储结点数量和数组长度的比值，当 load factor>=1，在未进行持久化时会进行 rehash，当 load facotr>5，强制进行 rehash。

### ZSet

Redis ZSet 底层使用 listpack 和跳表。元素个数小于 128，每个元素小于 64 字节使用 listpack；否则使用跳表。
跳表是一种多层级的双向链表，可以实现跨越式地遍历，添加、查找元素的时间复杂度为![](https://cdn.nlark.com/yuque/__latex/e8e0b4fcb6a9f3b41f64de387815a50b.svg#card=math&code=log%28n%29&id=rVArk)。

## 为什么 Lua 脚本可以保证原子性

Redis 在执行命令时是单线程的，Redis 在接收到 Lua 脚本后，会持续执行脚本中的命令直至结束，期间不会执行其他命令，这样保证了 Lua 脚本命令的原子性。

## MySQL 和 Redis 数据同步方式

MySQL 和 Redis 数据同步可以使用旁路缓存策略。这个策略分为两部分：读策略和写策略。在读策略中，首先读取缓存，缓存不命中则读取数据库并写入缓存。在写策略中，首先更新数据库，再删除缓存。

之所以删除缓存而不是更新缓存，是因为缓存内容可能使用了复杂的查询操作，更新缓存比增加缓存困难。

如果先删缓存，再更新数据库，由于数据库更新操作比较耗时，在两个操作之间有其他线程读，就会导致缓存旧数据，导致数据不一致。如果先更新数据库再删缓存，就不会出现上述问题。

## 缓存雪崩、缓存击穿、缓存穿透

缓存雪崩是指在同一时间内大量 key 同时过期，大量请求打到数据库，导致数据库压力骤增。解决方案是给过期时间都加上一个随机数，保证数据不会在同一时间过期。

缓存击穿是指某些热点 key 突然失效，导致大量请求访问数据库，导致数据库压力骤增。解决方案是不给 key 显式设置过期时间，使用后台线程根据需求操作缓存。

缓存穿透是指用户访问的数据既不在缓存中，也不在 MySQL 中，大量请求到达数据库，导致数据库压力骤增。缓存穿透解决方案：

1. 限制非法请求

例如不合法请求参数直接返回错误

2. 缓存空值或默认值

在线上业务发现缓存穿透现象时，可以针对查询数据，在缓存中设置空值。

3. 使用布隆过滤器快速判断数据不存在

布隆过滤器使用到了一个位图数组和多个哈希函数，每当数据库存储一个数据，就将该数据输入多个哈希函数，对位图数组长度取模，指定位置 1。查询布隆过滤器得知数据不存在，则数据库中一定不存在该数据。

## Redis 有哪些过期策略？

Redis 有主动过期和被动过期两种策略。

主动过期是指 Redis 使用异步线程主动扫描键，将过期的键值对删除。

被动过期是指当客户端访问某个键值对时，首先判断其是否过期，过期则删除。

## Redis 大 key 有什么问题？

Redis 大 key 是指存储大量数据的单个建。对大 key 的操作比较耗时，可能会阻塞其他操作。为了避免大 key 引发的问题，需要合理设计数据结构，将大 key 进行拆分，如果大 key 无法拆分，需要保证设置合适的过期时间，确保数据及时删除，避免长时间占用内存。
