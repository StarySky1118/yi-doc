# 3. 使用篇
## 为什么不推荐使用外键？
外键可以自动维护数据完整性约束，但实际使用中会出现性能和业务上的问题。

**性能问题**

性能问题主要包括：级联更新、额外检查和锁问题。

1. 级联更新

更新被引表时，可能触发引用表的级联更新，增大数据库压力。

2. 额外检查开销

每次在引用表中修改、新增记录都要进行外键约束检查，增大性能开销。

3. 锁问题

级联更新可能导致锁相关问题。

**业务问题**

1. 缺乏灵活性

强制外键约束缺乏灵活性，通常无法满足需求。

2. 分库条件下失效

分库条件下无法使用外键约束。

因此，实际使用中不会使用物理外键，而是通过业务代码进行相关约束。

## 为什么使用逻辑删除
逻辑删除是将记录标记为删除，而不是物理删除。
使用逻辑删除可以方便地进行数据恢复，便于审计与追溯。

## 有哪些常见的性能优化方案
主要包括 SQL 语句优化、库表设计优化和配置优化。

**SQL 语句优化**

SQL 语句优化是指使用 IO 和 CPU 成本更低的 SQL 语句。例如，避免使用 `select *`，仅选择必要的列、合理使用多表联查等

**库表设计优化**

库表设计优化包括合理使用索引、分库分表等。

**配置优化**

配置优化是指根据硬件条件与工作负载合理设置配置参数，例如连接池、日志参数等。

## InnoDB 存储引擎和 MyISAM 存储引擎有什么区别？
二者主要区别在事务和索引方面，其中最大的区别在事务方面。

InnoDB 存储引擎支持四种隔离级别的事务，而 MyISAM 存储引擎不支持事务。
因此不具备回滚能力、数据一致性保证能力、并发隔离能力和故障恢复能力。

InnoDB 聚簇索引叶子结点存放真实记录，而 MyISAM 聚簇索引叶子节点不存放真实数据，真实数据统一存放在别处。

## 如何实现数据库不停服迁移？
不停服迁移可以使用双写策略。

首先将新库作为旧库的从库，进行数据同步；
然后在业务代码中编写双写逻辑，即既写主库又写从库，双写操作要求能够使用配置实时开关；
数据同步完成后，在业务低峰期，开启双写；
持续进行数据核对；
确认双写代码无误，进入灰度切流状态，例如先将 1% 的读请求切到从库，逐步扩大，直到 100%；
继续保留双写，确保新库没有问题，关闭双写。

## MySQL 中 WAL 技术的实现？
WAL 是一种数据库日志管理技术，它的原理是在数据真正落盘之前，首先记录数据修改日志，这样一来，即使系统崩溃，
数据库仍能通过这个日志进行数据恢复。

MySQL 中 Redo Log 就是对 WAL 技术的一种实现，其工作流程是，数据修改落盘之前，先通过**顺序写**的方式在 Redo Log 中记录数据修改；
再经过**随机写**落盘。只要能够保证 Redo Log 成功落盘，该次数据修改就具备了崩溃恢复能力。

## `varchar(n)` 中的 `n` 指什么？
字符数目上限。

## 数据库三大范式是什么？
数据库第一范式确保字段都是原子值。该范式在实际业务开发中是遵守的。
第二范式在第一范式基础上，消除部分依赖。实际业务开发中表主键只有一个，该范式也是遵守的。
第三范式在第二范式基础上，消除传递依赖。在实际开发中，通常会采用冗余的方式减少多表联查，通常不会遵守该范式。

## DATETIME 和 TIMESTAMP 类型有什么区别？
DATETIME 是日期时间，只是单纯存储日期时间；
TIMESTAMP 是时间戳，表示到 1970-1-1 0:0:0 的毫秒数，会根据时区显示不同的时间日期。

## MySQL 中如何解决深度分页问题？
深度分页问题是指：当数据量非常大时，按分页访问后面的数据，需要首先跳过大量数据，然后只取小部分数据，查询速度显著变慢。

为解决深度分页问题，可以首先使用主键索引快速定位起始记录，再获取该页数据。这种解决方案只适合自增主键。

## MySQL 中 Inner join、Left join 和 right join 有什么区别？
Inner join 返回两表符合连接条件的交集。

Left join 返回左表中的每条记录，并将右表中符合连接条件的记录填入；若无，相应字段为 null。

Right join 返回右表中的每条记录，并将左表中符合连接条件的记录填入；若无，相应字段为 null。

## drop、delete 和 truncate 有什么区别？
drop 删表、delete 删记录、truncate 删表中所有记录。

## 多表联查选择驱动表时，应选择小表还是大表？
应选择小表作为驱动表。

由于驱动表需要全表扫描，被驱动表可以使用索引。因此将小表作为驱动表可以降低开销。

## MySQL 本身有缓存机制吗？
MySQL 使用 Buffer Pool 作为缓存，缓存表和索引。

读取数据时，首先读取 Buffer Pool 中的数据，缓存不命中再读取磁盘，并更新缓存；
修改数据时，首先修改 Buffer Pool 中的数据，等待时机落盘。


