# 3. 并发
## Java 线程和操作系统线程是怎样的对应关系？
Java 线程和操作系统线程通常是一一对应的。

## 多线程下通常有哪些问题？
多线程下通常包括同步与互斥问题。

同步是指多个线程之间有严格的执行顺序。

互斥是指多个线程互斥地访问共享资源。

## Java 线程有哪些状态？
当 `Thread` 类被创建，调用 `start()` 方法前，线程处于**新建态**。

调用 `start()` 方法，线程进入**可运行态**。这种状态相当于进程状态中的就绪态+运行态。

线程获取监视器锁失败，会进入**阻塞态**。

线程等待其他线程执行特定操作，进入**等待态**。

具有等待时间的等待态为**时间等待态**。

线程执行完成，进入**终止态**。

## 分别介绍一下 `synchrinized` 关键字和 `ReentrantLock`
`synchorinized` 关键字和 `ReentrantLock` 都可以实现线程同步。
它们的底层实现原理不同，适用于不同的线程同步场景。

`synchronized` 是一种内置锁，使用对象的监视器锁实现。

`ReentrantLock` 底层使用 AQS 实现，AQS 是一个抽象类，提供了基本线程同步的框架，包括队列、状态值、获取与释放方法等。
队列中可以存放获取不到锁的线程，因此可以基于 AQS 实现公平锁。
使用不同含义的状态值，搭配不同的获取与释放方法实现，就可以满足不同的同步需求。

`synchronized` 关键字适用于简单的线程同步场景，
但如果线程同步有更多需求，例如公平锁或使用条件变量协调线程之间的通信等，就需要 `ReentrantLock` 实现。

## 什么是可重入锁？如何实现可重入锁？
可重入锁是指线程获取锁后，可重复获取该锁，而不会产生死锁或其他问题。

可重入锁的实现原理是，锁内部包含一个计数器和线程标识。
当获取锁时，如果计数器为 0，则说明没有线程获取到锁，需要通过竞争的方式获取锁；
如果计数器大于 0，说明有线程获取到锁，再比较线程标识是否属于自己，如果属于自己，则可以直接获取到锁。
每次释放锁都要将计数器 -1，计数器为 0 才能通过竞争的方式获取锁。

## `voliatile` 关键字有何作用？
`voliatile` 关键字可以保证在多线程环境下，变量的可见性和有序性。

首先可见性，对 `voliatile` 修饰变量的修改，会直接写到主存；对变量的读取也会直接从主存读，保证了修改的可见性。

其次有序性，通过禁止指令重排序避免多线程下可能会导致的问题。

## 指令重排序是什么？
指令重排序是一种性能优化技术。但需要满足两个条件：
1. 单线程条件下，不改变程序执行结果
2. 存在数据依赖关系的语句不允许重排序

因此，指令重排序技术可能破坏多线程的执行语义。

## 公平锁和非公平锁的区别是什么？
公平锁指按申请顺序获取锁，非公平锁使用竞争方式获取锁。

公平锁底层使用一个队列，线程获取锁之前，首先进入队列排队，队首的线程才能获取到锁。



