import{_ as e,c as i,o as s,a}from"./app-CfWMsw_m.js";const d={},r=a('<h1 id="_2-线程模型" tabindex="-1"><a class="header-anchor" href="#_2-线程模型"><span>2. 线程模型</span></a></h1><h2 id="redis-为什么快" tabindex="-1"><a class="header-anchor" href="#redis-为什么快"><span>Redis 为什么快？</span></a></h2><p>Redis 速度快的原因包括基于内存、单线程模型和 I/O 多路复用。</p><p>首先，Redis 是基于内存的，并且采用了高效的数据结构。相比基于磁盘的方式要快得多。</p><p>其次，Redis 执行命令是单线程的，这就避免了多线程切换带来的额外开销。</p><p>最后，Redis 使用 I/O 多路复用机制，I/O 多路复用是指同一线程同时监听多个客户端连接，收到执行命令请求后交由 Server 执行。 避免了重复创建、断开连接带来的开销。</p><h2 id="redis-是单线程的吗" tabindex="-1"><a class="header-anchor" href="#redis-是单线程的吗"><span>Redis 是单线程的吗？</span></a></h2><p>Redis 执行命令时使用单线程模型，但 Redis 程序并不是单线程的。</p><p>Redis 程序本身还包括了多个后台线程，例如关闭文件、AOF 刷盘、释放内存、处理 I/O 请求等。 这些任务相对耗时，如果让这些任务共用执行命令的线程，执行命令任务可能会长时间阻塞。</p>',9),t=[r];function n(c,l){return s(),i("div",null,t)}const h=e(d,[["render",n],["__file","2-线程模型.html.vue"]]),o=JSON.parse('{"path":"/dev/principle/redis/2-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html","title":"2. 线程模型","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Redis 为什么快？","slug":"redis-为什么快","link":"#redis-为什么快","children":[]},{"level":2,"title":"Redis 是单线程的吗？","slug":"redis-是单线程的吗","link":"#redis-是单线程的吗","children":[]}],"git":{"updatedTime":1725412272000,"contributors":[{"name":"ZhangZiYi","email":"ecustzzy1@163.com","commits":1}]},"filePathRelative":"dev/principle/redis/2-线程模型.md"}');export{h as comp,o as data};
