import{_ as e,c as a,o as l,a as i}from"./app-DFLTi-q-.js";const n={},c=i('<h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h1><h2 id="linux-零拷贝" tabindex="-1"><a class="header-anchor" href="#linux-零拷贝"><span>Linux 零拷贝</span></a></h2><p>零拷贝是一种优化技术，旨在<strong>减少数据在内存中的拷贝次数</strong>，从而提高数据传输效率和系统性能。在 Linux 中，零拷贝通常用于网络传输和文件操作中。其原理是尽量<strong>避免用户态和内核态数据的重复拷贝</strong>。</p><p>Linux 中常用的零拷贝技术是 <code>sendfile</code>，它使用网卡的 DMA，直接将内核缓冲区的数据拷贝到网卡，大幅减少了数据拷贝次数和系统调用次数。</p><h2 id="在-linux-上定位磁盘已满、cpu-利用率过高的问题" tabindex="-1"><a class="header-anchor" href="#在-linux-上定位磁盘已满、cpu-利用率过高的问题"><span>在 Linux 上定位磁盘已满、CPU 利用率过高的问题</span></a></h2><h3 id="磁盘情况" tabindex="-1"><a class="header-anchor" href="#磁盘情况"><span>磁盘情况</span></a></h3><p>使用 <code>df -h</code>命令查看文件系统磁盘空间的使用情况。</p><h3 id="cpu-使用情况" tabindex="-1"><a class="header-anchor" href="#cpu-使用情况"><span>CPU 使用情况</span></a></h3><p>使用 <code>top</code>命令查看进程的 CPU 使用率、内存使用率等。使用数字 <code>1</code>键可以展开显示各个 CPU 核心的使用情况。</p><p>如果一个 Java 进程的 CPU 使用率非常高，很可能是程序编码出现问题，需要查看 Java 线程的堆栈信息。步骤如下：</p><ol><li>使用 <code>ps -ef | grep java</code>找出 Java 进程的 PID</li><li>使用 <code>jstack pid &gt; thread_dump.txt</code>打印堆栈信息</li></ol><h2 id="乐观锁与悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁与悲观锁"><span>乐观锁与悲观锁</span></a></h2><p>乐观锁与悲观锁是处理互斥资源共享的两种策略。</p><p>乐观锁乐观之处在于，它认为资源共享不会出现问题，多个线程可以随便读，只是在提交修改时使用版本号或 CAS 锁保证同步。 版本号机制是在提交修改时，比对当前记录版本号与之前读到的版本号是否一致，保证读写之间没有其他线程修改。 CAS 锁机制是在提交修改时，比对之前读到的属性值与当前记录属性值是否一致，保证读写之间没有其他线程修改。 CAS 最大问题是 ABA 问题，即一个线程读写之间有其他线程将属性从 A 改到 B，再从 B 改到 A，这样就未能保证操作的原子性。CAS 算法另一个问题是频繁重试操作引起的 CPU 利用率过高。</p><p>悲观锁悲观之处在于，它认为资源共享一定会出现问题，多个线程要访问资源，首先要获取到互斥锁才能访问，获取不到互斥锁就会阻塞。</p><p>Java 的 <code>sychronized</code>关键字就同时使用到了乐观锁与悲观锁，底层的监视器锁可以根据线程竞争的激烈程度进行锁升级。</p><h2 id="进程间通信的方法" tabindex="-1"><a class="header-anchor" href="#进程间通信的方法"><span>进程间通信的方法</span></a></h2><p>进程间通信分为主机内通信和跨主机通信。主机内通讯方法包括管道、消息队列、共享内存、信号量、信号，主机间通讯需要借助网络。</p><p>管道通信包括匿名管道和命名管道。匿名管道是一种单向通信方式，适用于具有亲缘关系的进程之间进行数据传输；命名管道是一种双向通信方式，可以在没有亲缘关系的进程之间进行双向通信。Linux 操作系统中的 <code>|</code>就是管道通信的典型应用，它可以将前一个命令的结果作为后一个命令的输入，它的实现原理是 fork 两个子进程，将前一个子进程的输出端重定向到管道的写端，将第二个子进程的输入端重定向到管道的读端，实现进程通信。</p><p>消息队列是一种异步的通信方式。发送方将消息发送至队列，接收方从队列中读取消息。 消息队列应用极为广泛，不仅被使用在进程通信中，在现代微服务架构中，服务间通信可以使用消息队列，确保服务之间的松耦合。</p><p>共享内存是一种高效的进程间通信方式，它允许多个进程同时操作相同的物理地址空间，避免了数据的复制与传输。 共享内存通信方式需要考虑进程的并发控制，避免数据不一致。这就用到了信号量。</p><p>信号量可以保证进程间的同步与互斥。进程同步指进程间保证严格的执行顺序，进程互斥指进程间排他地访问共享资源。</p><p>信号是一种在 Linux 系统中常用的进程间通信方式，用于在进程之间传递简单的消息或通知，常用于异常处理场景，例如在 Linux 中，使用 <code>kill</code>命令杀掉进程；或使用 <code>Ctrl+C</code>终止进程。</p><h2 id="linux-目录结构" tabindex="-1"><a class="header-anchor" href="#linux-目录结构"><span>Linux 目录结构</span></a></h2><p>Linux 目录结构是一种树状结构，根是根目录，用 <code>/</code>表示。常见目录包括：</p><ol><li><code>bin</code>：存放系统用户常用的命令</li><li><code>dev</code>：存放设备文件</li><li><code>etc</code>：存放系统配置文件</li><li><code>opt</code>：存放可选的应用程序和软件包</li><li><code>usr</code>：存放系统用户的应用程序、库文件等</li></ol><h2 id="进程与线程有什么区别" tabindex="-1"><a class="header-anchor" href="#进程与线程有什么区别"><span>进程与线程有什么区别？</span></a></h2><p>线程与进程最大区别在于：线程是 CPU 调度的基本单位，而进程是资源分配的基本单位。 进程拥有完整的资源，如内存、打开的文件，而同一进程内的线程共享所属进程的资源，只独享必不可少的资源，如程序计数器等。 同一进程内线程间切换开销较小，进程间切换开销较大。</p><h2 id="进程调度算法" tabindex="-1"><a class="header-anchor" href="#进程调度算法"><span>进程调度算法</span></a></h2><p>进程调度算法包括先来先服务、短作业优先、高响应比优先算法、轮转法和多级反馈队列。</p><p>先来先服务算法按照进程的到达顺序进行调度，先到达的进程先执行。这种调度方法存在一个问题，一个服务时间很长的进程最先到达，那么后续到达的进程就会等待很长时间。</p><p>短作业优先算法优先调度预估执行时间最短的进程。但这也会产生一个问题，短作业不断到达，长作业可能会长时间饥饿，因此需要将等待时间纳入考量。</p><p>高响应比优先算法使用响应比作为优先级，响应比与等待时间和服务时间的比值成正相关。这种算法平衡了服务时间和等待时间。</p><p>轮转法为进程分配固定时间片，按顺序循环调度。</p><p>多级反馈队列算法使用多个不同优先级的队列，优先级越高，时间片越短。算法的流程是进程首先进入最高优先级队列等待执行，若未执行完，继续进入低优先级队列等待执行。反馈是指如果一个进程在低优先队列中长时间饥饿，操作系统就会调度其到高优先级队列执行。</p><h2 id="进程有哪几种状态-如何转换" tabindex="-1"><a class="header-anchor" href="#进程有哪几种状态-如何转换"><span>进程有哪几种状态？如何转换？</span></a></h2><p>操作系统进程包括 5 中状态：新建态、就绪态、运行态、阻塞态和终止态。</p><p>当一个进程刚刚被创建，没有加载到内存中时，他处于新建态。当这个进程被加载到内存中，添加到就绪队列中，进程进入就绪态。当进程被调度到 CPU 中执行，进程进入运行态。当运行态的进程时间片用完或者被更高优先级的进程抢占 CPU，进程进入就绪态。当运行态进程等待某个事件完成（例如 IO 操作），进程进入阻塞态。阻塞态进程事件完成后，重新进入就绪态。运行态进程执行完毕，进入终止态。</p>',38),p=[c];function d(s,t){return l(),a("div",null,p)}const o=e(n,[["render",d],["__file","1-操作系统.html.vue"]]),r=JSON.parse('{"path":"/dev/principle/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html","title":"操作系统","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Linux 零拷贝","slug":"linux-零拷贝","link":"#linux-零拷贝","children":[]},{"level":2,"title":"在 Linux 上定位磁盘已满、CPU 利用率过高的问题","slug":"在-linux-上定位磁盘已满、cpu-利用率过高的问题","link":"#在-linux-上定位磁盘已满、cpu-利用率过高的问题","children":[{"level":3,"title":"磁盘情况","slug":"磁盘情况","link":"#磁盘情况","children":[]},{"level":3,"title":"CPU 使用情况","slug":"cpu-使用情况","link":"#cpu-使用情况","children":[]}]},{"level":2,"title":"乐观锁与悲观锁","slug":"乐观锁与悲观锁","link":"#乐观锁与悲观锁","children":[]},{"level":2,"title":"进程间通信的方法","slug":"进程间通信的方法","link":"#进程间通信的方法","children":[]},{"level":2,"title":"Linux 目录结构","slug":"linux-目录结构","link":"#linux-目录结构","children":[]},{"level":2,"title":"进程与线程有什么区别？","slug":"进程与线程有什么区别","link":"#进程与线程有什么区别","children":[]},{"level":2,"title":"进程调度算法","slug":"进程调度算法","link":"#进程调度算法","children":[]},{"level":2,"title":"进程有哪几种状态？如何转换？","slug":"进程有哪几种状态-如何转换","link":"#进程有哪几种状态-如何转换","children":[]}],"git":{"updatedTime":1723702370000,"contributors":[{"name":"ZhangZiYi","email":"ecustzzy1@163.com","commits":2}]},"filePathRelative":"dev/principle/1-操作系统.md"}');export{o as comp,r as data};
